Bonjour [Nom du destinataire],Je vous écris suite au refus de ma demande avec le motif "merci de créé une demande unitaire ir Groupe." Pourriez-vous m'expliquer ce que cela signifie exactement et quelles sont les étapes à suivre ?Merci d'avance pour votre aide.Cordialement,
Nihad Senhadji




Given that you have access to Azure OpenAI LLM APIs, we can leverage them to build your chatbot. Here’s how you can extend the implementation to use Azure OpenAI, handle text, tables, and flowcharts, and ensure the generated procedures include these elements.High-Level StepsExtract and Store Existing Content: Extract text, tables, and flowcharts from PDFs.Index the Content: Store and index the content for efficient retrieval.Retrieve Relevant Content: Fetch relevant documents, tables, and flowcharts based on a user query.Generate New Procedures: Use Azure OpenAI API to generate new procedures, ensuring that tables and flowcharts are integrated.Validate the Generated Procedure: Validate the generated procedure against the specified rules.









Here is the complete integrated script to create a chatbot that uses Azure OpenAI LLM APIs to generate new procedures, including text, tables, and flowcharts.

```python
import fitz
from PIL import Image
import pytesseract
import io
import pdfplumber
from sentence_transformers import SentenceTransformer
import faiss
import numpy as np
import openai

# Function to extract text and tables from PDFs
def extract_text_and_tables_from_pdf(pdf_path):
    text = ""
    tables = []
    with pdfplumber.open(pdf_path) as pdf:
        for page in pdf.pages:
            text += page.extract_text()
            tables.extend(page.extract_tables())
    return text, tables

# Function to extract images from PDFs
def extract_images_from_pdf(pdf_path):
    doc = fitz.open(pdf_path)
    images = []
    for page in doc:
        image_list = page.get_images(full=True)
        for img_index, img in enumerate(image_list):
            xref = img[0]
            base_image = doc.extract_image(xref)
            image_bytes = base_image["image"]
            image = Image.open(io.BytesIO(image_bytes))
            images.append(image)
    return images

# Paths to your PDFs
existing_procedure_path = "path_to_existing_procedure.pdf"
new_doc_path = "path_to_new_doc.pdf"
procedure_rules_path = "path_to_procedure_rules.pdf"

# Extract texts, tables, and images
existing_procedure_text, existing_procedure_tables = extract_text_and_tables_from_pdf(existing_procedure_path)
new_doc_text, new_doc_tables = extract_text_and_tables_from_pdf(new_doc_path)
procedure_rules_text, procedure_rules_tables = extract_text_and_tables_from_pdf(procedure_rules_path)

existing_procedure_images = extract_images_from_pdf(existing_procedure_path)
new_doc_images = extract_images_from_pdf(new_doc_path)
procedure_rules_images = extract_images_from_pdf(procedure_rules_path)

# Load a sentence transformer model and embed documents
embedding_model = SentenceTransformer('all-MiniLM-L6-v2')
docs = [existing_procedure_text, new_doc_text, procedure_rules_text]
embeddings = embedding_model.encode(docs)

# Index embeddings using FAISS
dimension = embeddings.shape[1]
index = faiss.IndexFlatL2(dimension)
index.add(np.array(embeddings))

# Store tables and images separately
all_tables = [existing_procedure_tables, new_doc_tables, procedure_rules_tables]
all_images = [existing_procedure_images, new_doc_images, procedure_rules_images]

# Function to retrieve documents and assets
def retrieve_documents_and_assets(query, top_k=2):
    query_embedding = embedding_model.encode([query])
    _, indices = index.search(query_embedding, top_k)
    retrieved_docs = [docs[idx] for idx in indices[0]]
    retrieved_tables = [all_tables[idx] for idx in indices[0]]
    retrieved_images = [all_images[idx] for idx in indices[0]]
    return retrieved_docs, retrieved_tables, retrieved_images

# User query example
user_query = "Write a new procedure for our new system."
retrieved_docs, retrieved_tables, retrieved_images = retrieve_documents_and_assets(user_query)

# Configure Azure OpenAI API
openai.api_type = "azure"
openai.api_base = "https://your-resource-name.openai.azure.com/"
openai.api_version = "2023-05-15"
openai.api_key = "your-azure-openai-key"

# Function to generate new procedures with assets using Azure OpenAI
def generate_new_procedure_with_assets(query, retrieved_docs, retrieved_tables, retrieved_images, procedure_rules):
    retrieved_text = "\n\n".join(retrieved_docs)
    tables_text = "\n\n".join(["Table:\n" + str(table) for tables in retrieved_tables for table in tables])
    images_text = "\n\n".join(["Flowchart:\n" + pytesseract.image_to_string(image) for images in retrieved_images for image in images])
    
    input_text = (f"User Query: {query}\n\n"
                  f"Retrieved Documents:\n{retrieved_text}\n\n"
                  f"Retrieved Tables:\n{tables_text}\n\n"
                  f"Retrieved Flowcharts:\n{images_text}\n\n"
                  f"Procedure Writing Rules:\n{procedure_rules}\n\n"
                  f"Write a new procedure based on the above information and rules:"
                  f"Ensure that new tables and flowcharts are generated where necessary.")

    response = openai.Completion.create(
        engine="davinci",
        prompt=input_text,
        max_tokens=1500
    )
    return response.choices[0].text.strip()

new_procedure = generate_new_procedure_with_assets(user_query, retrieved_docs, retrieved_tables, retrieved_images, procedure_rules_text)
print(new_procedure)

# Function to validate the generated procedure
def validate_procedure(procedure, rules):
    validation_results = {}
    for rule_key, rule in rules.items():
        if "title" in rule:
            validation_results[rule_key] = "title" in procedure.lower()
        elif "simple and clear language" in rule:
            # Implement your own validation logic
            validation_results[rule_key] = True  # Placeholder
        # Add more rule checks as necessary
    return validation_results

# Define rules
rules = {
    "rule_1": "Each procedure must include a clear title.",
    "rule_2": "Procedures must be written in simple and clear language.",
    # Add more rules as necessary
}

# Validate the generated procedure
validation_results = validate_procedure(new_procedure, rules)
print(validation_results)
```

This script covers the entire workflow from extracting and storing content from existing PDFs to generating new procedures with Azure OpenAI and validating them against predefined rules. Make sure to replace the placeholder values like file paths and API keys with actual values relevant to your use case.






termes de :Nom et prénom / raison socialeDate de naissance / créationLieu de naissance / créationNous pouvons ajouter les données supplémentaires que vous souhaitez dans le fichier final et vous pouvez nous indiquer les éléments à inclure.Le fichier Excel final "Résultats_DECAD_juin_2024" que nous vous avons envoyé contient trois feuilles distinctes :Enregistrements avec un score de similarité supérieur à 95 % avec un score de similarité inférieur à 95 %Piste d'audit : Vous trouverez ici l'ensemble des fichiers DECAD analysés, ainsi que les résultats finaux du fichier DECAD de juin. La colonne "nom_interdicted_chequiers" est la concaténation des deux premières colonnes du fichier DECAD.Nous vous invitons à examiner ces résultats et à nous communiquer vos observations ou les données complémentaires que vous souhaitez voir ajoutées.Résumé des résultats :Nombre total d'enregistrements analysés : 18 000Pourcentage d'enregistrements similaires : 7 %Nous restons à votre disposition pour toute question ou clarification.Vous trouverez ci-joint la vidéo de démonstration ainsi que la présentation.Cordialement,Nihad Senhadji
BNP Paribas El DjazairPièce jointe : Résultats_Analyse_Similarité_DECAD.xlsx, Vidéo_Demo.mp4, Présentation.pdfAssurez-vous d'adapter le nom des fichiers et de joindre les bons fichiers avant d'envoyer votre email.
