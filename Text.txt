"Réécrivez la procédure existante en vous basant uniquement sur la documentation du nouvel outil, en vous assurant que le document final ait le même nombre de pages que l'original. Maintenez le même format et la même structure, et reproduisez le style d'écriture tout au long du document. Modifiez le contenu uniquement là où il y a des mises à jour ou des changements pertinents dans la documentation du nouvel outil. Par exemple, si le nom de l'outil change, remplacez simplement les noms, comme dans la phrase 'Nous utilisons l'outil Minsa pour les nouveaux clients', que vous devez modifier en 'Nous utilisons Nostra pour les nouveaux clients'. Si aucun changement n'est nécessaire, conservez l'écriture originale intacte. Assurez-vous que la procédure mise à jour soit claire, précise et cohérente avec les capacités du nouvel outil, tout en préservant la longueur et le style globaux du document original."



import os
import httpx
import json
from PyPDF2 import PdfReader
from fpdf import FPDF
from dotenv import load_dotenv
from httpx import OAuth2ClientCredentials

# Step 1: Load environment variables from .env file (if using dotenv)
load_dotenv()

# Set up OAuth2 and Azure API credentials
OIDC_ENDPOINT = "https://aifactory.api.staging.echonet/auth/oauth2/v2/token"
OIDC_CLIENT_ID = os.getenv("OIDC_CLIENT_ID")
OIDC_CLIENT_SECRET = os.getenv("OIDC_CLIENT_SECRET")
OIDC_SCOPE = "genai-model"
APIGEE_ENDPOINT = "https://aifactory.api.staging.echonet/genai-model/v1"
AZURE_ADAI_MODEL_DEPLOYMENT_NAME = "gpt4turbo"
AZURE_AOAI_API_VERSION = "2024-02-15-preview"
AZURE_AOAI_API_KEY = os.getenv("AZURE_AOAI_API_KEY")

# Step 2: Set up the OAuth2 client with httpx
oauth2_httpxclient = httpx.Client(verify=False)

auth = OAuth2ClientCredentials(
    OIDC_ENDPOINT,
    client_id=OIDC_CLIENT_ID,
    client_secret=OIDC_CLIENT_SECRET,
    scope=OIDC_SCOPE,
    client=oauth2_httpxclient
)

# Step 3: Function to extract text from a PDF
def extract_pdf_text(pdf_path):
    with open(pdf_path, 'rb') as file:
        reader = PdfReader(file)
        text = ''
        for page in reader.pages:
            text += page.extract_text()
        return text

# Step 4: Generate the prompt for GPT-4
def generate_prompt(old_procedure, new_tool_docs):
    prompt = f"""
    You are tasked with migrating an old tool's procedure to a new tool's process.
    Here is the procedure from the old tool:

    {old_procedure}

    Here is the documentation for the new tool:

    {new_tool_docs}

    Rewrite the procedure using the new tool's instructions and processes.
    """
    return prompt

# Step 5: Function to interact with Azure OpenAI GPT-4 via OAuth2 authentication
def update_procedure_with_gpt4(old_procedure, new_tool_docs):
    prompt = generate_prompt(old_procedure, new_tool_docs)

    # Create the HTTP request to Azure OpenAI via Apigee with OAuth2
    response = httpx.post(
        f"{APIGEE_ENDPOINT}/openai/deployments/{AZURE_ADAI_MODEL_DEPLOYMENT_NAME}/chat/completions?api-version={AZURE_AOAI_API_VERSION}",
        headers={"Authorization": f"Bearer {auth}", "Content-Type": "application/json"},
        json={
            "model": AZURE_ADAI_MODEL_DEPLOYMENT_NAME,
            "messages": [
                {"role": "system", "content": "You are an assistant helping to rewrite procedures."},
                {"role": "user", "content": prompt}
            ],
            "max_tokens": 1500,
            "temperature": 0.7
        }
    )
    
    # Check for errors in response
    if response.status_code != 200:
        raise Exception(f"API request failed: {response.status_code} - {response.text}")

    updated_procedure = response.json()['choices'][0]['message']['content'].strip()
    return updated_procedure

# --- Character encoding fixes ---

# 1. Clean unsupported characters by replacing them with simpler ones
def clean_text(text):
    return text.replace("\u2013", "-")  # Replace en-dash with a regular dash

# 2. Strip non-ASCII characters as a fallback option
def remove_non_ascii(text):
    return ''.join([char if ord(char) < 128 else ' ' for char in text])

# 3. Use a Unicode-friendly font (DejaVuSans) with FPDF
def save_to_pdf(updated_text, output_pdf_path, font_path=None):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()

    # If a Unicode-friendly font is provided, use it
    if font_path:
        pdf.add_font('DejaVu', '', font_path, uni=True)
        pdf.set_font("DejaVu", size=12)
    else:
        pdf.set_font("Arial", size=12)

    # Split text by lines and add each line separately
    lines = updated_text.split('\n')

    for line in lines:
        # Handle empty lines
        if line.strip() == "":
            pdf.ln(10)
        else:
            pdf.multi_cell(0, 10, txt=line, align='L')

    pdf.output(output_pdf_path)

# --- Example usage ---

# Old and new procedure files
old_pdf_path = "old_procedures.pdf"
new_tool_docs = "Insert new tool's documentation here or load dynamically"

# Step 7: Extract text from old PDF
old_procedures = extract_pdf_text(old_pdf_path)

# Step 8: Use GPT-4 to update the procedures
updated_procedures = update_procedure_with_gpt4(old_procedures, new_tool_docs)

# Choose your encoding fix:
# cleaned_procedures = clean_text(updated_procedures)  # Option 1: Clean special characters
# ascii_procedures = remove_non_ascii(updated_procedures)  # Option 2: Strip non-ASCII characters

# Step 9: Save the updated procedures to a new PDF
output_pdf_path = "updated_procedures.pdf"
font_path = "/path/to/DejaVuSans.ttf"  # Adjust path to your font file

# Save using Unicode-supporting font or default Arial
save_to_pdf(updated_procedures, output_pdf_path, font_path=font_path)  # With Unicode support
# save_to_pdf(cleaned_procedures, output_pdf_path)  # With cleaned text
# save_to_pdf(ascii_procedures, output_pdf_path)  # With ASCII-only text

print(f"Updated procedures saved to {output_pdf_path}")






import os
import httpx
import json
from PyPDF2 import PdfReader
from fpdf import FPDF
from dotenv import load_dotenv
from azure.ai.openai import OpenAIClient
from azure.identity import ClientSecretCredential

# Load environment variables from .env file (if using dotenv)
load_dotenv()

# Set up OAuth2 and Azure API credentials
OIDC_ENDPOINT = "https://aifactory.api.staging.echonet/auth/oauth2/v2/token"
OIDC_CLIENT_ID = os.getenv("OIDC_CLIENT_ID")
OIDC_CLIENT_SECRET = os.getenv("OIDC_CLIENT_SECRET")
OIDC_SCOPE = "genai-model"
APIGEE_ENDPOINT = "https://aifactory.api.staging.echonet/genai-model/v1"
AZURE_ADAI_MODEL_DEPLOYMENT_NAME = "gpt4turbo"
AZURE_AOAI_API_VERSION = "2024-02-15-preview"
AZURE_AOAI_API_KEY = os.getenv("AZURE_AOAI_API_KEY")

# Function to fetch OAuth2 token
def fetch_oauth2_token(client):
    try:
        response = client.post(
            OIDC_ENDPOINT,
            data={
                "grant_type": "client_credentials",
                "client_id": OIDC_CLIENT_ID,
                "client_secret": OIDC_CLIENT_SECRET,
                "scope": OIDC_SCOPE
            }
        )
        response.raise_for_status()  # Raise an error for bad responses
        return response.json()  # Return the token response as JSON
    except Exception as e:
        print(f"Error fetching token: {e}")
        return None

# Step 5: Function to interact with Azure OpenAI GPT-4 via OAuth2 authentication
def update_procedure_with_gpt4(old_procedure, new_tool_docs):
    prompt = generate_prompt(old_procedure, new_tool_docs)

    # Create an httpx client for OAuth2 token retrieval
    http_client = httpx.Client(verify=False)
    access_token = None

    # Loop to check if the token is retrieved from cache (simulated)
    for i in range(3):  # Retry fetching token up to 3 times
        if access_token is None:
            token_response = fetch_oauth2_token(http_client)
            if token_response:
                access_token = token_response.get("access_token")
                if access_token:
                    break  # Exit the loop if token is retrieved

    if not access_token:
        raise Exception("Failed to retrieve access token after multiple attempts.")

    # Create the Azure OpenAI client
    openai_client = OpenAIClient(
        api_version=AZURE_AOAI_API_VERSION,
        azure_endpoint=APIGEE_ENDPOINT,
        api_key=AZURE_AOAI_API_KEY,
        http_client=http_client
    )

    # Create the chat completion request
    completion = openai_client.chat.completions.create(
        model=AZURE_ADAI_MODEL_DEPLOYMENT_NAME,
        messages=[
            {"role": "system", "content": "You are an assistant helping to rewrite procedures."},
            {"role": "user", "content": prompt}
        ]
    )

    updated_procedure = completion.choices[0].message.content.strip()
    return updated_procedure

# Example usage
old_pdf_path = "old_procedures.pdf"
new_tool_docs = "Insert new tool's documentation here or load dynamically"

# Step 7: Extract text from old PDF
old_procedures = import os
import httpx
from PyPDF2 import PdfReader
from fpdf import FPDF
from dotenv import load_dotenv
from azure.ai.openai import OpenAIClient

# Load environment variables from .env file
load_dotenv()

# Set up OAuth2 and Azure API credentials
OIDC_ENDPOINT = "https://aifactory.api.staging.echonet/auth/oauth2/v2/token"
OIDC_CLIENT_ID = os.getenv("OIDC_CLIENT_ID")
OIDC_CLIENT_SECRET = os.getenv("OIDC_CLIENT_SECRET")
OIDC_SCOPE = "genai-model"
APIGEE_ENDPOINT = "https://aifactory.api.staging.echonet/genai-model/v1"
AZURE_ADAI_MODEL_DEPLOYMENT_NAME = "gpt4turbo"
AZURE_AOAI_API_VERSION = "2024-02-15-preview"
AZURE_AOAI_API_KEY = os.getenv("AZURE_AOAI_API_KEY")

# Function to fetch OAuth2 token
def fetch_oauth2_token(client):
    try:
        response = client.post(
            OIDC_ENDPOINT,
            data={
                "grant_type": "client_credentials",
                "client_id": OIDC_CLIENT_ID,
                "client_secret": OIDC_CLIENT_SECRET,
                "scope": OIDC_SCOPE
            }
        )
        response.raise_for_status()
        return response.json()  # Return the token response as JSON
    except Exception as e:
        print(f"Error fetching token: {e}")
        return None

# Step 5: Function to interact with Azure OpenAI GPT-4 via OAuth2 authentication
def update_procedure_with_gpt4(old_procedure, new_tool_docs):
    prompt = generate_prompt(old_procedure, new_tool_docs)

    # Create an httpx client for OAuth2 token retrieval
    http_client = httpx.Client(verify=False)
    access_token = None

    # Loop to check if the token is retrieved from cache
    for i in range(1, 4):
        # Attempt to fetch the OAuth2 token
        token_response = fetch_oauth2_token(http_client)
        if token_response:
            access_token = token_response.get("access_token")
            if access_token:
                print(f"Access token retrieved on attempt {i}")
                break  # Exit the loop if the token is retrieved
        print(f"Attempt {i} to retrieve access token failed.")

    if not access_token:
        raise Exception("Failed to retrieve access token after multiple attempts.")

    # Initialize the Azure OpenAI client with the retrieved token
    azure_openai_client = OpenAIClient(
        api_version=AZURE_AOAI_API_VERSION,
        azure_endpoint=APIGEE_ENDPOINT,
        api_key=AZURE_AOAI_API_KEY,
        http_client=httpx.Client(auth=access_token, verify=False)  # Use access token for auth
    )

    # Create the chat completion request
    completion = azure_openai_client.chat.completions.create(
        model=AZURE_ADAI_MODEL_DEPLOYMENT_NAME,
        messages=[
            {"role": "user", "content": prompt}
        ]
    )

    updated_procedure = completion.choices[0].message.content.strip()
    print(updated_procedure)  # Print the updated procedure
    return updated_procedure

# Function to extract text from a PDF
def extract_pdf_text(pdf_path):
    with open(pdf_path, 'rb') as file:
        reader = PdfReader(file)
        text = ''
        for page in reader.pages:
            text += page.extract_text()
        return text

# Generate the prompt for GPT-4
def generate_prompt(old_procedure, new_tool_docs):
    prompt = f"""
    You are tasked with migrating an old tool's procedure to a new tool's process.
    Here is the procedure from the old tool:

    {old_procedure}

    Here is the documentation for the new tool:

    {new_tool_docs}

    Rewrite the procedure using the new tool's instructions and processes.
    """
    return prompt

# Function to save updated text into a PDF
def save_to_pdf(updated_text, output_pdf_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Add updated procedure line by line
    for line in updated_text.split('\n'):
        pdf.cell(200, 10, txt=line, ln=True, align='L')

    pdf.output(output_pdf_path)

# Example usage
old_pdf_path = "old_procedures.pdf"
new_tool_docs = "Insert new tool's documentation here or load dynamically"

# Step 7: Extract text from old PDF
old_procedures = extract_pdf_text(old_pdf_path)

# Step 8: Use GPT-4 to update the procedures
updated_procedures = update_procedure_with_gpt4(old_procedures, new_tool_docs)

# Step 9: Save the updated procedures to a new PDF
output_pdf_path = "/mnt/LMMS/updated_procedures.pdf"
save_to_pdf(updated_procedures, output_pdf_path)

print(f"Updated procedures saved to {output_pdf_path}")




extract_pdf_text(old_pdf_path)

# Step 8: Use GPT-4 to update the procedures
updated_procedures = update_procedure_with_gpt4(old_procedures, new_tool_docs)

# Step 9: Save the updated procedures to a new PDF
output_pdf_path = "/mnt/LMMS/updated_procedures.pdf"
save_to_pdf(updated_procedures, output_pdf_path)

print(f"Updated procedures saved to {output_pdf_path}")


# Step 2: Set up the OAuth2 client with httpx
oauth2_httpxclient = httpx.Client(verify=False)

# Step 3: Function to fetch OAuth2 token
def fetch_oauth2_token():
    response = oauth2_httpxclient.post(
        OIDC_ENDPOINT,
        data={
            "grant_type": "client_credentials",
            "client_id": OIDC_CLIENT_ID,
            "client_secret": OIDC_CLIENT_SECRET,
            "scope": OIDC_SCOPE
        }
    )
    response.raise_for_status()  # Raise an error for bad responses
    return response.json()  # Return the token response as JSON

# Step 5: Function to interact with Azure OpenAI GPT-4 via OAuth2 authentication
def update_procedure_with_gpt4(old_procedure, new_tool_docs):
    prompt = generate_prompt(old_procedure, new_tool_docs)

    # Fetch OAuth2 token
    token_response = fetch_oauth2_token()  # Fetch OAuth2 token using the new function
    access_token = token_response["access_token"]  # Extract the access token

    # Create the HTTP request to Azure OpenAI via Apigee with OAuth2
    response = httpx.post(
        f"{APIGEE_ENDPOINT}/openai/deployments/{AZURE_ADAI_MODEL_DEPLOYMENT_NAME}/chat/completions?api-version={AZURE_AOAI_API_VERSION}",
        headers={"Authorization": f"Bearer {access_token}", "Content-Type": "application/json"},
        json={
            "model": AZURE_ADAI_MODEL_DEPLOYMENT_NAME,
            "messages": [
                {"role": "system", "content": "You are an assistant helping to rewrite procedures."},
                {"role": "user", "content": prompt}
            ],
            "max_tokens": 1500,
            "temperature": 0.7
        }
    )
    
    # Check for errors in response
    if response.status_code != 200:
        raise Exception(f"API request failed: {response.status_code} - {response.text}")

    updated_procedure = response.json()['choices'][0]['message']['content'].strip()
    return updated_procedure


import os
import httpx
import json
from PyPDF2 import PdfReader
from fpdf import FPDF
from dotenv import load_dotenv
from httpx import OAuth2ClientCredentials

# Step 1: Load environment variables from .env file (if using dotenv)
load_dotenv()

# Set up OAuth2 and Azure API credentials
OIDC_ENDPOINT = "https://aifactory.api.staging.echonet/auth/oauth2/v2/token"
OIDC_CLIENT_ID = os.getenv("OIDC_CLIENT_ID")
OIDC_CLIENT_SECRET = os.getenv("OIDC_CLIENT_SECRET")
OIDC_SCOPE = "genai-model"
APIGEE_ENDPOINT = "https://aifactory.api.staging.echonet/genai-model/v1"
AZURE_ADAI_MODEL_DEPLOYMENT_NAME = "gpt4turbo"
AZURE_AOAI_API_VERSION = "2024-02-15-preview"
AZURE_AOAI_API_KEY = os.getenv("AZURE_AOAI_API_KEY")

# Step 2: Set up the OAuth2 client with httpx
oauth2_httpxclient = httpx.Client(verify=False)

auth = OAuth2ClientCredentials(
    OIDC_ENDPOINT,
    client_id=OIDC_CLIENT_ID,
    client_secret=OIDC_CLIENT_SECRET,
    scope=OIDC_SCOPE,
    client=oauth2_httpxclient
)

# Step 3: Function to extract text from a PDF
def extract_pdf_text(pdf_path):
    with open(pdf_path, 'rb') as file:
        reader = PdfReader(file)
        text = ''
        for page in reader.pages:
            text += page.extract_text()
        return text

# Step 4: Generate the prompt for GPT-4
def generate_prompt(old_procedure, new_tool_docs):
    prompt = f"""
    You are tasked with migrating an old tool's procedure to a new tool's process.
    Here is the procedure from the old tool:

    {old_procedure}

    Here is the documentation for the new tool:

    {new_tool_docs}

    Rewrite the procedure using the new tool's instructions and processes.
    """
    return prompt

# Step 5: Function to interact with Azure OpenAI GPT-4 via OAuth2 authentication
def update_procedure_with_gpt4(old_procedure, new_tool_docs):
    prompt = generate_prompt(old_procedure, new_tool_docs)

    # Fetch OAuth2 token
    token_response = auth.fetch_token()  # Fetch OAuth2 token
    access_token = token_response["access_token"]  # Extract the access token

    # Create the HTTP request to Azure OpenAI via Apigee with OAuth2
    response = httpx.post(
        f"{APIGEE_ENDPOINT}/openai/deployments/{AZURE_ADAI_MODEL_DEPLOYMENT_NAME}/chat/completions?api-version={AZURE_AOAI_API_VERSION}",
        headers={"Authorization": f"Bearer {access_token}", "Content-Type": "application/json"},
        json={
            "model": AZURE_ADAI_MODEL_DEPLOYMENT_NAME,
            "messages": [
                {"role": "system", "content": "You are an assistant helping to rewrite procedures."},
                {"role": "user", "content": prompt}
            ],
            "max_tokens": 1500,
            "temperature": 0.7
        }
    )
    
    # Check for errors in response
    if response.status_code != 200:
        raise Exception(f"API request failed: {response.status_code} - {response.text}")

    updated_procedure = response.json()['choices'][0]['message']['content'].strip()
    return updated_procedure

# Step 6: Function to save updated text into a PDF
def save_to_pdf(updated_text, output_pdf_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Add updated procedure line by line
    for line in updated_text.split('\n'):
        pdf.cell(200, 10, txt=line, ln=True, align='L')

    pdf.output(output_pdf_path)

# Example usage
old_pdf_path = "old_procedures.pdf"
new_tool_docs = "Insert new tool's documentation here or load dynamically"

# Step 7: Extract text from old PDF
old_procedures = extract_pdf_text(old_pdf_path)

# Step 8: Use GPT-4 to update the procedures
updated_procedures = update_procedure_with_gpt4(old_procedures, new_tool_docs)

# Step 9: Save the updated procedures to a new PDF
output_pdf_path = "updated_procedures.pdf"
save_to_pdf(updated_procedures, output_pdf_path)

print(f"Updated procedures saved to {output_pdf_path}")




import os
import httpx
import json
from PyPDF2 import PdfReader
from fpdf import FPDF
from dotenv import load_dotenv
from httpx import OAuth2ClientCredentials

# Step 1: Load environment variables from .env file (if using dotenv)
load_dotenv()

# Set up OAuth2 and Azure API credentials
OIDC_ENDPOINT = "https://aifactory.api.staging.echonet/auth/oauth2/v2/token"
OIDC_CLIENT_ID = os.getenv("OIDC_CLIENT_ID")
OIDC_CLIENT_SECRET = os.getenv("OIDC_CLIENT_SECRET")
OIDC_SCOPE = "genai-model"
APIGEE_ENDPOINT = "https://aifactory.api.staging.echonet/genai-model/v1"
AZURE_ADAI_MODEL_DEPLOYMENT_NAME = "gpt4turbo"
AZURE_AOAI_API_VERSION = "2024-02-15-preview"
AZURE_AOAI_API_KEY = os.getenv("AZURE_AOAI_API_KEY")

# Step 2: Set up the OAuth2 client with httpx
oauth2_httpxclient = httpx.Client(verify=False)

auth = OAuth2ClientCredentials(
    OIDC_ENDPOINT,
    client_id=OIDC_CLIENT_ID,
    client_secret=OIDC_CLIENT_SECRET,
    scope=OIDC_SCOPE,
    client=oauth2_httpxclient
)

# Step 3: Function to extract text from a PDF
def extract_pdf_text(pdf_path):
    with open(pdf_path, 'rb') as file:
        reader = PdfReader(file)
        text = ''
        for page in reader.pages:
            text += page.extract_text()
        return text

# Step 4: Generate the prompt for GPT-4
def generate_prompt(old_procedure, new_tool_docs):
    prompt = f"""
    You are tasked with migrating an old tool's procedure to a new tool's process.
    Here is the procedure from the old tool:

    {old_procedure}

    Here is the documentation for the new tool:

    {new_tool_docs}

    Rewrite the procedure using the new tool's instructions and processes.
    """
    return prompt

# Step 5: Function to interact with Azure OpenAI GPT-4 via OAuth2 authentication
def update_procedure_with_gpt4(old_procedure, new_tool_docs):
    prompt = generate_prompt(old_procedure, new_tool_docs)

    # Create the HTTP request to Azure OpenAI via Apigee with OAuth2
    response = httpx.post(
        f"{APIGEE_ENDPOINT}/openai/deployments/{AZURE_ADAI_MODEL_DEPLOYMENT_NAME}/chat/completions?api-version={AZURE_AOAI_API_VERSION}",
        headers={"Authorization": f"Bearer {auth}", "Content-Type": "application/json"},
        json={
            "model": AZURE_ADAI_MODEL_DEPLOYMENT_NAME,
            "messages": [
                {"role": "system", "content": "You are an assistant helping to rewrite procedures."},
                {"role": "user", "content": prompt}
            ],
            "max_tokens": 1500,
            "temperature": 0.7
        }
    )
    
    # Check for errors in response
    if response.status_code != 200:
        raise Exception(f"API request failed: {response.status_code} - {response.text}")

    updated_procedure = response.json()['choices'][0]['message']['content'].strip()
    return updated_procedure

# Step 6: Function to save updated text into a PDF
def save_to_pdf(updated_text, output_pdf_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Add updated procedure line by line
    for line in updated_text.split('\n'):
        pdf.cell(200, 10, txt=line, ln=True, align='L')

    pdf.output(output_pdf_path)

# Example usage
old_pdf_path = "old_procedures.pdf"
new_tool_docs = "Insert new tool's documentation here or load dynamically"

# Step 7: Extract text from old PDF
old_procedures = extract_pdf_text(old_pdf_path)

# Step 8: Use GPT-4 to update the procedures
updated_procedures = update_procedure_with_gpt4(old_procedures, new_tool_docs)

# Step 9: Save the updated procedures to a new PDF
output_pdf_path = "updated_procedures.pdf"
save_to_pdf(updated_procedures, output_pdf_path)

print(f"Updated procedures saved to {output_pdf_path}")





import openai
import PyPDF2
from fpdf import FPDF

# Step 1: Set up Azure OpenAI API credentials
openai.api_type = "azure"
openai.api_base = "https://YOUR_AZURE_OPENAI_ENDPOINT/"
openai.api_version = "2023-03-15-preview"
openai.api_key = "YOUR_AZURE_OPENAI_API_KEY"

# Step 2: Function to extract text from a PDF
def extract_pdf_text(pdf_path):
    with open(pdf_path, 'rb') as file:
        reader = PyPDF2.PdfReader(file)
        text = ''
        for page in reader.pages:
            text += page.extract_text()
        return text

# Step 3: GPT-4 prompt generation for procedure rewriting
def generate_prompt(old_procedure, new_tool_docs):
    prompt = f"""
    You are tasked with migrating an old tool's procedure to a new tool's process.
    Here is the procedure from the old tool:

    {old_procedure}

    Here is the documentation for the new tool:

    {new_tool_docs}

    Rewrite the procedure using the new tool's instructions and processes.
    """
    return prompt

# Step 4: Function to interact with GPT-4 and get the updated procedures
def update_procedure_with_gpt4(old_procedure, new_tool_docs):
    prompt = generate_prompt(old_procedure, new_tool_docs)
    
    response = openai.Completion.create(
        engine="gpt-4",  # Use "gpt-4" engine on Azure OpenAI
        prompt=prompt,
        max_tokens=1500,
        n=1,
        stop=None,
        temperature=0.7
    )
    
    updated_procedure = response['choices'][0]['text'].strip()
    return updated_procedure

# Step 5: Function to save updated text into a PDF
def save_to_pdf(updated_text, output_pdf_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Add updated procedure line by line
    for line in updated_text.split('\n'):
        pdf.cell(200, 10, txt=line, ln=True, align='L')

    pdf.output(output_pdf_path)

# Example usage
old_pdf_path = "old_procedures.pdf"
new_tool_docs = "Insert new tool's documentation here or load dynamically"

# Step 6: Extract text from old PDF
old_procedures = extract_pdf_text(old_pdf_path)

# Step 7: Use GPT-4 to update the procedures
updated_procedures = update_procedure_with_gpt4(old_procedures, new_tool_docs)

# Step 8: Save the updated procedures to a new PDF
output_pdf_path = "updated_procedures.pdf"
save_to_pdf(updated_procedures, output_pdf_path)

print(f"Updated procedures saved to {output_pdf_path}")




import pdfplumber
import openai
from PyPDF2 import PdfReader, PdfWriter

# Step 1: Extract Text from PDFs
def extract_pdf_text(pdf_path):
    """
    Extracts the text from a PDF file.
    
    :param pdf_path: Path to the PDF file
    :return: Extracted text as a string
    """
    with pdfplumber.open(pdf_path) as pdf:
        full_text = ''
        for page in pdf.pages:
            full_text += page.extract_text()
    return full_text

# Step 2: Set up Azure OpenAI API
openai.api_type = "azure"
openai.api_base = "https://<your-resource-name>.openai.azure.com/"  # Replace with your Azure resource URL
openai.api_version = "2023-03-15-preview"
openai.api_key = "<your-azure-openai-api-key>"  # Replace with your Azure API key

def adjust_modifications_with_documentation(target_text, documentation_text):
    """
    Uses GPT-4 to suggest modifications to a target PDF based on a documentation PDF.

    :param target_text: Text from the target PDF
    :param documentation_text: Text from the documentation PDF
    :return: Suggested modifications from GPT-4
    """
    prompt = (
        f"Based on the following documentation, suggest modifications for the target contract "
        f"to ensure compliance and alignment with best practices:\n\n"
        f"Documentation:\n{documentation_text}\n\n"
        f"Target Contract:\n{target_text}\n\n"
        f"Please suggest the necessary changes."
    )
    
    response = openai.Completion.create(
        engine="gpt-4",  # You can also use gpt-35-turbo if you prefer
        prompt=prompt,
        temperature=0.5,
        max_tokens=1500
    )
    return response.choices[0].text.strip()

# Step 3: Modify PDF Based on GPT-4 Suggestions
def apply_modifications_to_pdf(pdf_path, output_path, suggestions):
    """
    Adds the GPT-4 suggestions to the PDF as metadata or applies modifications.
    
    :param pdf_path: Path to the target PDF
    :param output_path: Path to save the modified PDF
    :param suggestions: Text containing modification suggestions
    """
    reader = PdfReader(pdf_path)
    writer = PdfWriter()

    # Add the suggestions as metadata (you can modify this to add annotations or comments)
    writer.add_metadata({
        '/Modifications_Suggestions': suggestions
    })

    for page in reader.pages:
        writer.add_page(page)

    with open(output_path, 'wb') as f:
        writer.write(f)

    print(f"Modified PDF saved at: {output_path}")

# Step 4: Main Workflow
def main(target_pdf_path, documentation_pdf_path, output_pdf_path):
    """
    Orchestrates the process of extracting text, sending to GPT-4, and applying the modifications.

    :param target_pdf_path: Path to the target PDF to be modified
    :param documentation_pdf_path: Path to the reference documentation PDF
    :param output_pdf_path: Path to save the modified PDF
    """
    # Extract text from the target PDF and the documentation PDF
    target_text = extract_pdf_text(target_pdf_path)
    documentation_text = extract_pdf_text(documentation_pdf_path)

    # Get modification suggestions from GPT-4
    suggestions = adjust_modifications_with_documentation(target_text, documentation_text)
    print("GPT-4 Suggestions:", suggestions)

    # Apply modifications or add comments to the PDF
    apply_modifications_to_pdf(target_pdf_path, output_pdf_path, suggestions)

# Example usage
if __name__ == "__main__":
    # Replace these with the actual paths to your files
    target_pdf_path = "target_contract.pdf"  # Target PDF file
    documentation_pdf_path = "documentation.pdf"  # Documentation PDF file
    output_pdf_path = "modified_contract_with_suggestions.pdf"  # Output file

    main(target_pdf_path, documentation_pdf_path, output_pdf_path)



Inaccurate Identification: AI may incorrectly match names


This use case involves implementing an AI-based system using NLP to compare the similarity between names and surnames from Atlas' customer database and the BA cheque defaulters blacklist. We will verify if it is the same individual by checking the date of birth (or date of creation for companies) and the place of birth. The results will be compiled into an Excel file, with one sheet for matches with a similarity score ≥ 95% and another for scores < 95%. This ensures a thorough verification process, reducing false matches and accurately identifying defaulters.




This use case involves implementing an AI-based system using NLP to compare the similarity between names and surnames from Atlas' customer database and the BA cheque defaulters blacklist. When a potential match is identified, the system will confirm if it is the same individual by verifying the date of birth (or date of creation for companies) and the place of birth. This approach ensures a thorough verification process, reducing false positives and accurately identifying defaulters.




https://forms.office.com/Pages/ResponsePage.aspx?id=JZxPYfq_x0KG2JZBAfVfom6FMzcQ6YZGjty1QNO8NZtUQzJUWjdWUVZHNE42M00yR0FKUlVBMkJXOC4u&origin=QRCode&qrcodeorigin=presentation



Objet : Version finale du quiz

Bonjour [Nom du Manager],

Voici la version finale du quiz. Vous pouvez également consulter la vidéo "DECAD AI" en suivant ce lien : [chemin/URL].

Cordialement,
Nihad




Avez-vous une idée du nombre de lignes traitées mensuellement pour le flux domestique, provenant du fichier DECAD envoyé par la BA ?


DECAD traite les interdits de chéquier par la vérification manuelle des clients signalés comme interdits de chéquier

"Savez-vous combien de fois la Banque d'Algérie envoie les fichiers des interdits de chéquiers ?"



"Savez-vous combien de temps il faut pour traiter les fichiers des interdits de chéquiers par le flux Domestique ?"

"Savez-vous combien de temps la Banque d'Algérie met pour envoyer les fichiers des interdits de chéquiers ?"



[Scène 1 : Ouverture - Écran titre]
Texte à l'écran : "Révolutionner les processus manuels avec l'IA chez BNP Paribas El Djazair"

[Scène 2 : Présentation du problème - Visuel du traitement manuel des données]
Narrateur : "Chaque mois, nous traitons plus de 2 200 enregistrements, en vérifiant manuellement les clients interdits de chéquiers. Ce processus est long et comporte un risque élevé d'erreurs à cause des variations de noms et des homonymes."

[Scène 3 : Présentation de la solution IA - Visuel du traitement des données par l'IA]
Narrateur : "Avec notre solution d'IA, DECAD, alimentée par le traitement avancé du langage naturel, nous avons automatisé ce processus complexe. L'IA identifie les similarités phonétiques, même avec des variations de noms."

[Scène 4 : Les avantages - Visuel d'un tableau de bord montrant les gains d'efficacité]
Narrateur : "Cette solution réduit le travail manuel de 93%, augmente la précision, et garantit la conformité avec les réglementations bancaires—le tout en seulement 42 jours/homme."

[Scène 5 : Conclusion - Logo de la banque et slogan]
Narrateur : "L'IA chez BNP Paribas El Djazair : transformer les tâches manuelles pour un avenir plus 
